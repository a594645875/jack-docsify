## 相关面试题

##### 1. HashMap的原理，内部数据结构？

- 底层使用哈希表（数组+单向链表），当链表过长会将链表转成红黑树以实现O(logn)时间复杂度内查找

##### 2. 讲一下HashMap中put方法过程？

1. 对key求hash，然后再计算下标
2. 如果没有碰撞，直接放入桶中
3. 如果碰撞了，以链表的方式链接到后面
4. 如果链表的长度超过阀值（TREEIFY_THRESHOLD == 8），则把链表转成红黑树
5. 如果节点已经存在就替换该值
6. 如果槽满了（容量*加载因子），就需要扩容(resize)，（**容量因子默认0.75**）

##### 3. HashMap中hash函数是怎么实现的？还有哪些hash的实现方式

1. 高16bit不变，低16bit和高16bit做了一个异或得到hash
2. (n-1) & hash 得到下标
3. 还有哪些hash的实现方式：[哈希的多种实现方式](https://blog.csdn.net/qq_37954088/article/details/79692032)

##### 4. HashMap怎么解决冲突？讲一下扩容过程？假如一个值在原数组中，扩容后，怎么定位这个值在新数组中的位置？

- 将产生冲突的新节点加到链表后
- 容量扩充为原来的两倍，然后对每个节点重新计算哈希值
- 这个值只能在两个地方，一个是原下表的位置，一个是在下标为（原下标 + 原容量）的位置

##### 5. 抛开HashMap（链地址法），哈希冲突有哪些解决办法？

- 开放定址法，再哈希法  [详解](https://www.cnblogs.com/jiumo/p/10471048.html)

##### 6. 针对HashMap中某个Entry链太长，查找的时间复杂度可能达到O(n)，怎么优化？

- 将链表转成红黑树，JDK1.8已经实现。

