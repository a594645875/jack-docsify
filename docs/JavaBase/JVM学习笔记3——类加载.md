#  JVM——类加载

## 1. 类加载阶段

### 1.1 加载

将类的字节码载入方法区中

### 1.2 连接

- 验证，验证类是否符合 JVM规范，安全性检查
- 准备，为 static 变量分配空间，设置默认值
- 解析，将常量池中的符号引用解析为直接引用

### 1.3 初始化

- 定义：初始化即调用 <cinit>()V ，虚拟机会保证这个类的『构造方法』的线程安全

- 初始化时机：
  - main 方法所在的类，总会被首先初始化
  - 首次访问这个类的静态变量或静态方法时
  - 子类初始化，如果父类还没初始化，会引发
  - 子类访问父类的静态变量，只会触发父类的初始化
  - Class.forName
  - new 会导致初始化
- 不会初始化的情况：
  - 访问类的 static fifinal 静态常量（基本类型和字符串）不会触发初始化
  - 类对象.class 不会触发初始化
  - 创建该类的数组不会触发初始化

## 2. 类加载器

### 2.1 加载器等级

| 名称                    | 加载类的路径          | 说明                          |
| ----------------------- | --------------------- | ----------------------------- |
| Bootstrap ClassLoader   | JAVA_HOME/jre/lib     | 无法直接访问                  |
| Extension ClassLoader   | JAVA_HOME/jre/lib/ext | 上级为 Bootstrap，显示为 null |
| Application ClassLoader | classpath             | 上级为 Extension              |
| 自定义类加载器          | 自定义                | 上级为 Application            |

Bootstrap是C++代码实现的，所以在Java代码中查询为null。

此处的上下级并非继承关系，与继承无关。

### 2.2 双亲委派模式

定义：

- 如果一个类加载器收到了加载某个类的请求,则该类加载器并不会去加载该类,而是把这个请求委派给父类加载器,每一个层次的类加载器都是如此,因此所有的类加载请求最终都会传送到顶端的启动类加载器;只有当父类加载器在其搜索范围内无法找到所需的类,并将该结果反馈给子类加载器,子类加载器会尝试去自己加载。

辅助概念：

- 对于任意一个类，都需要由加载它的类加载器和这个类本身来一同确立其在Java虚拟机中的唯一性。

JDK在数据库驱动的实现上需要有破坏双亲委派模式的案例

### 2.3 自定义类加载器

使用场景：

- 想加载非 classpath 随意路径中的类文件
- 都是通过接口来使用实现，希望解耦时，常用在框架设计
- 这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器

实现步骤：

- 继承 ClassLoader 父类
- 要遵从双亲委派机制，重写 fifindClass 方法
  - 注意不是重写 loadClass 方法，否则不会走双亲委派机制
- 读取类文件的字节码
- 调用父类的 defifineClass 方法来加载类
- 使用者调用该类加载器的 loadClass 方法