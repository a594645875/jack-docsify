## 9. JAVA锁

参考文献: [JAVA锁有哪些种类](https://blog.csdn.net/nalanmingdian/article/details/77800355)

### 9.1 锁分类

这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计思想。

**按性质分类：**

- #### 乐观锁/悲观锁

乐观锁：每次去拿数据的时候不会上锁，在更新的时候会使用版本号等机制判断有没有别人更新了这个数据，乐观锁适用于多读的应用场景，这样可以提高吞吐量。
例子：在Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式`CAS`(`Compare and Swap` 比较并交换)实现的。

悲观锁：每次去拿数据的时候都认为别人会修改，所以每次拿数据都会上锁，别人想拿数据就会阻塞直到它拿到锁。
例子：Java里面的同步原语synchronized关键字的实现就是悲观锁。

- #### 公平锁/非公平锁  

公平锁：多个线程按照申请锁的顺序来获取锁。

非公平锁：多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，缺点可能会造成优先级反转或者饥饿现象。优点在于吞吐量比公平锁大。

例子：`ReetrantLock`通过构造函数指定该锁是否是公平锁，默认是非公平锁。`Synchronized`也是一种非公平锁，并且不能使其变成公平锁。

- #### 独享锁/共享锁

独享锁：该锁一次只能被一个线程所持有。例子：`ReadWriteLock`的写锁，`ReentrantLock`，`Synchronized`

共享锁：该锁可被多个线程所持有。例子：`ReadWriteLock`的读锁（作者觉得这严格来说不叫锁。）

- #### 互斥锁/读写锁

独享锁/共享锁是一种广义的说法，互斥锁/读写锁是具体的实现。

- #### 可重入锁

又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。例子：看名字就知道的`ReetrantLock`和`Synchronized`



**按设计思想分类：**

- #### 自旋锁/自适应自旋锁

自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

- #### 偏向锁/轻量级锁/重量级锁

这三种锁是指锁的状态，并且是针对`Synchronized`。是在Java 5通过引入锁升级（也叫锁膨胀，只有升级没有降级）的机制来实现高效`Synchronized`。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。

**偏向锁**：一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。

**轻量级锁**：当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

**重量级锁**：当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。

- #### 锁粗化/锁消除

锁粗化：一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。当虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。

锁消除：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

- #### 分段锁

分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。例子：`ConcurrentHashMap`中的分段锁称为`Segment`，它即类似于`HashMap`（JDK7与JDK8中`HashMap`的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个`ReentrantLock`（Segment继承了`ReentrantLock`)。当需要put元素的时候，并不是对整个`hashmap`进行加锁，而是先通过`hashcode`来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入

### 9.2 常用锁

- Synchronized
- ReentrantLock
- ReadWriteLock
- Semaphore
- AtomicInteger
